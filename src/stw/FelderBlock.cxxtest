#include "stw/FelderBlock.h"
#include "stw/RouteLever.h"
#include "test_main.h"
#include "utils/MockPin.h"

enum BlockId : uint8_t {
  BLOCK_AB,
  BLOCK_CD,
};

/// These identifiers are used for fake GPIO registration.
enum GpioId : gpio_pin_t {
  MIN_GPIO = 35,
  AB_LOCK_BTN,
  AB_LOCK_FIELD,
  AB_DETECTOR,
  AB_VORBLOCK_IN,
  AB_ENDFELD,
  AB_RUCKBLOCK_IN,
  AB_ANFANGSFELD,
  AB_ABGABE_IN,
  AB_ERLAUBNISFELD,
  AB_STORUNGSMELDER,
  AB_HALTSTELLMELDER,
  AB_STRECKENTASTENSPERRE,
  
  KURBEL,

  NUM_GPIO  // always last.

};

/// Fake implementation of the I2C block interface. It does not communicate via
/// I2C, but exposes the raw status bits to the owner.
struct FakeI2CBlock : public I2CBlockInterface {
  FakeI2CBlock(uint16_t* ext_status)
      : ext_status_(ext_status) {}

  void set_status(uint16_t status) override {
    *ext_status_ = status;
  }

  uint16_t get_status() override {
    return *ext_status_;
  }
  
 private:
  uint16_t* ext_status_;
};

class FelderBlockTest : public TestBase {
 protected:
  FelderBlockTest() {
    block_.check_setup(block_setup_);
    set(BlockBits::STARTUP);
    set(BlockBits::NEWINPUT);
  }

  void begin() {
    ex_.begin();
  }

  bool has(BlockBits bit) {
    return line_status_ & bit;
  }

  void set(BlockBits bit) {
    line_status_ |= (uint16_t)bit;
  }

  void clr(BlockBits bit) {
    line_status_ &= ~(uint16_t)bit;
  }

  void wait() {
    for (unsigned i = 0; i < 100; ++i) {
      ex_.advance(1);
      ex_.loop();
    }
  }
  
  GpioRegistry gpio_reg_;
  TurnoutRegistry turnout_reg_;
  SignalRegistry signal_reg_;
  RouteRegistry route_reg_;
  BlockRegistry block_reg_;
  GlobalState g_cmd_;

  uint16_t line_status_{0};
  FakeI2CBlock i2c_blk_{&line_status_};
  
  FakeGpio gpios_{MIN_GPIO, NUM_GPIO - MIN_GPIO};
  FelderBlock block_{&i2c_blk_, BLOCK_AB, AB_DETECTOR,   false, AB_LOCK_BTN,
                     false,    AB_LOCK_FIELD, false};
  const uint16_t block_setup_ = 
      block_.set_vorblock_taste(AB_VORBLOCK_IN, false) |
      block_.set_ruckblock_taste(AB_RUCKBLOCK_IN, false) |
      block_.set_abgabe_taste(AB_ABGABE_IN, false) |
      block_.set_kurbel(KURBEL, false) |
      block_.set_anfangsfeld(AB_ANFANGSFELD, false) |
      block_.set_endfeld(AB_ENDFELD, false) |
      block_.set_erlaubnisfeld(AB_ERLAUBNISFELD, false) |
      block_.set_storungsmelder(AB_STORUNGSMELDER, false) |
      block_.set_signalhaltmelder(AB_HALTSTELLMELDER, false) |
      block_.set_streckentastensperre(AB_STRECKENTASTENSPERRE, false);
};

TEST_F(FelderBlockTest, create) {}

TEST_F(FelderBlockTest, create2) {
  begin();
  wait();
}

TEST_F(FelderBlockTest, startup_state) {
  begin();
  wait();
  EXPECT_FALSE(gpios_.read(AB_ENDFELD));
}

TEST_F(FelderBlockTest, unlocked_ruckblock) {
  g_cmd_.is_unlocked_ = true;
  begin();
  wait();
  gpios_.write(AB_RUCKBLOCK_IN, true);
  gpios_.write(KURBEL, true);
  wait();
  EXPECT_FALSE(has(BlockBits::TRACK_OUT));
  EXPECT_TRUE(has(BlockBits::HANDOFF));
  EXPECT_FALSE(has(BlockBits::IN_BUSY));
  EXPECT_TRUE(has(BlockBits::NEWOUTPUT));

  EXPECT_FALSE(gpios_.read(AB_ERLAUBNISFELD));
  EXPECT_TRUE(gpios_.read(AB_ENDFELD));
  EXPECT_TRUE(gpios_.read(AB_ANFANGSFELD));

  gpios_.write(AB_RUCKBLOCK_IN, false);
  gpios_.write(KURBEL, false);
  clr(BlockBits::NEWOUTPUT);
  wait();
}

TEST_F(FelderBlockTest, unlocked_handoff) {
  g_cmd_.is_unlocked_ = true;
  begin();
  wait();
  gpios_.write(AB_ABGABE_IN, true);
  gpios_.write(KURBEL, true);
  wait();
  EXPECT_FALSE(has(BlockBits::TRACK_OUT));
  EXPECT_TRUE(has(BlockBits::HANDOFF));
  EXPECT_TRUE(has(BlockBits::NEWOUTPUT));
  EXPECT_FALSE(has(BlockBits::IN_BUSY));
  EXPECT_FALSE(has(BlockBits::OUT_BUSY));

  EXPECT_FALSE(gpios_.read(AB_ERLAUBNISFELD));
  EXPECT_TRUE(gpios_.read(AB_ENDFELD));
  EXPECT_TRUE(gpios_.read(AB_ANFANGSFELD));

  gpios_.write(AB_ABGABE_IN, false);
  gpios_.write(KURBEL, false);
  clr(BlockBits::NEWOUTPUT);
  wait();
}

TEST_F(FelderBlockTest, unlocked_vorblock) {
  g_cmd_.is_unlocked_ = true;
  begin();
  wait();
  gpios_.write(AB_VORBLOCK_IN, true);
  gpios_.write(KURBEL, true);
  wait();
  EXPECT_TRUE(has(BlockBits::TRACK_OUT));
  EXPECT_FALSE(has(BlockBits::HANDOFF));
  EXPECT_TRUE(has(BlockBits::NEWOUTPUT));
  EXPECT_FALSE(has(BlockBits::IN_BUSY));
  EXPECT_TRUE(has(BlockBits::OUT_BUSY));

  EXPECT_TRUE(gpios_.read(AB_ERLAUBNISFELD));
  EXPECT_TRUE(gpios_.read(AB_ENDFELD));
  EXPECT_FALSE(gpios_.read(AB_ANFANGSFELD));
  
  gpios_.write(AB_ABGABE_IN, false);
  gpios_.write(KURBEL, false);
  clr(BlockBits::NEWOUTPUT);
  wait();
}


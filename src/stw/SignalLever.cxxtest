#include "stw/SignalLever.h"

//

#include "test_main.h"
#include "utils/MockPin.h"

class SignalTestBase : public TestBase {
 protected:
  SignalTestBase() {
    gpio_reg_.register_obj(&lever_, 13);
    gpio_reg_.register_obj(&lock_, 14);

    EXPECT_CALL(lever_, set_input(13));
    EXPECT_CALL(lock_, set_output(14));
  }

  GpioRegistry gpio_reg_;
  StrictMock<MockGpio> lever_;
  StrictMock<MockGpio> lock_;
};

enum SignalId : uint8_t { SIG_A, SIG_B, SIG_C };

class SignalLeverTest : public SignalTestBase {
 protected:
  SignalLeverTest() {}

  void begin() {
    EXPECT_CALL(lever_, read(13)).WillOnce(Return(false));
    ex_.begin();
  }

  SignalRegistry t_reg_;
  SignalLever sgl_{SIG_B, HP2, 13, false, 14, false};
};

TEST_F(SignalLeverTest, create) {}

TEST_F(SignalLeverTest, registered) {
  EXPECT_EQ(&sgl_,
            SignalRegistry::instance()->get(signal_registry_idx(SIG_B, HP2)));
}

TEST_F(SignalLeverTest, locked_unlocked) {
  begin();
  EXPECT_TRUE(sgl_.is_locked());
  EXPECT_EQ(HP0, sgl_.current_aspect());
  sgl_.unlock();
  EXPECT_FALSE(sgl_.is_locked());
  EXPECT_EQ(HP0, sgl_.current_aspect());

  EXPECT_CALL(lock_, write(14, false));
  EXPECT_CALL(lever_, read(13)).WillOnce(Return(false));
  ex_.loop();
  EXPECT_EQ(HP0, sgl_.current_aspect());
  EXPECT_FALSE(sgl_.is_locked());
}

TEST_F(SignalLeverTest, locked_no_read) {
  begin();
  EXPECT_TRUE(sgl_.is_locked());
  EXPECT_EQ(HP0, sgl_.current_aspect());

  // input never read
  EXPECT_CALL(lock_, write(14, true));
  ex_.loop();
  EXPECT_TRUE(sgl_.is_locked());
  EXPECT_EQ(HP0, sgl_.current_aspect());
  EXPECT_FALSE(sgl_.is_proceed());
}

TEST_F(SignalLeverTest, lock_invert) {
  ex_.~Executor();
  new (&ex_) Executor();

  EXPECT_CALL(lever_, set_input(13));
  EXPECT_CALL(lock_, set_output(14));

  new (&sgl_) SignalLever{SIG_B, HP1, 13, false, 14, true};

  EXPECT_CALL(lever_, read(13)).WillOnce(Return(false));
  ex_.begin();

  EXPECT_CALL(lock_, write(14, false));
  ex_.loop();

  sgl_.unlock();

  EXPECT_CALL(lever_, read(13)).WillOnce(Return(false));
  EXPECT_CALL(lock_, write(14, true));
  ex_.loop();
}

TEST_F(SignalLeverTest, proceed) {
  begin();
  EXPECT_FALSE(sgl_.is_proceed());

  sgl_.unlock();
  EXPECT_FALSE(sgl_.is_locked());
  EXPECT_EQ(HP0, sgl_.current_aspect());

  EXPECT_CALL(lock_, write(14, false));
  EXPECT_CALL(lever_, read(13)).WillOnce(Return(false));
  ex_.loop();
  EXPECT_EQ(HP0, sgl_.current_aspect());
  EXPECT_FALSE(sgl_.is_locked());
  EXPECT_FALSE(sgl_.is_proceed());

  // Enable the signal
  EXPECT_CALL(lock_, write(14, false));
  EXPECT_CALL(lever_, read(13)).WillOnce(Return(true));
  ex_.loop();

  EXPECT_EQ(HP2, sgl_.current_aspect());
  EXPECT_FALSE(sgl_.is_locked());
  EXPECT_TRUE(sgl_.is_proceed());

  // return to normal
  EXPECT_CALL(lock_, write(14, false));
  EXPECT_CALL(lever_, read(13)).WillOnce(Return(false));
  ex_.loop();

  EXPECT_EQ(HP0, sgl_.current_aspect());
  EXPECT_TRUE(sgl_.is_locked());
  EXPECT_FALSE(sgl_.is_proceed());

  // lock at the next loop
  EXPECT_CALL(lock_, write(14, true));
  ex_.loop();
}

TEST_F(SignalLeverTest, lever_invert) {
  ex_.~Executor();
  new (&ex_) Executor();

  EXPECT_CALL(lever_, set_input(13));
  EXPECT_CALL(lock_, set_output(14));

  new (&sgl_) SignalLever{SIG_B, HP1, 13, true, 14, false};

  EXPECT_CALL(lever_, read(13)).WillOnce(Return(true));
  ex_.begin();

  EXPECT_CALL(lock_, write(14, true));
  ex_.loop();

  sgl_.unlock();

  EXPECT_CALL(lever_, read(13)).WillOnce(Return(false));
  EXPECT_CALL(lock_, write(14, false));
  ex_.loop();

  EXPECT_TRUE(sgl_.is_proceed());
  EXPECT_EQ(HP1, sgl_.current_aspect());

  // Lever closed again
  EXPECT_CALL(lever_, read(13)).WillOnce(Return(true));
  EXPECT_CALL(lock_, write(14, false));
  ex_.loop();

  EXPECT_FALSE(sgl_.is_proceed());
  EXPECT_EQ(HP0, sgl_.current_aspect());
  EXPECT_TRUE(sgl_.is_locked());

  EXPECT_CALL(lock_, write(14, true));
  ex_.loop();
}
